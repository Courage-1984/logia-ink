/**
 * Video Optimization Script for Web Background
 *
 * Optimizes videos for infinite background playback on the web:
 * - Multiple resolutions/qualities (HQ, MQ, LQ)
 * - MP4 (H.264) + WebM (VP9)
 * - Network optimization for streaming
 * - Generates poster image
 * - Generates poster image
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { existsSync, mkdirSync, readdir } from 'fs';
import { writeFile } from 'fs/promises';
import { join, dirname, basename, extname } from 'path';
import { fileURLToPath } from 'url';

const readdirAsync = promisify(readdir);

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Config
const INPUT_DIR = 'assets/video';
const OUTPUT_DIR = 'assets/video/optimized';
const FADE_DURATION = 1; // seconds for fade in/out

// Supported video file extensions
const VIDEO_EXTENSIONS = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v', '.flv', '.wmv'];

const SETTINGS = {
  hq: {
    width: 1920,
    height: 1080,
    bitrate: '2M',
    crf: 23,
    fps: 30,
    format: 'mp4',
    codec: 'libx264',
    preset: 'medium',
    profile: 'baseline',
    level: '3.1',
  },
  mq: {
    width: 1280,
    height: 720,
    bitrate: '1.5M',
    crf: 23,
    fps: 30,
    format: 'mp4',
    codec: 'libx264',
    preset: 'medium',
    profile: 'baseline',
    level: '3.1',
  },
  lq: {
    width: 854,
    height: 480,
    bitrate: '800k',
    crf: 25,
    fps: 24,
    format: 'mp4',
    codec: 'libx264',
    preset: 'medium',
    profile: 'baseline',
    level: '3.0',
  },
  webm: {
    width: 1920,
    height: 1080,
    bitrate: '2M',
    crf: 30,
    fps: 30,
    format: 'webm',
    codec: 'libvpx-vp9',
    preset: 'medium',
  },
};

// Helpers
function parseBitrate(bitrate) {
  if (bitrate.toLowerCase().endsWith('k')) return parseInt(bitrate) * 1000;
  if (bitrate.toLowerCase().endsWith('m')) return parseInt(bitrate) * 1000000;
  return parseInt(bitrate);
}

async function checkFFmpeg() {
  try {
    await execAsync('ffmpeg -version');
    return true;
  } catch {
    console.error('âŒ ffmpeg not found in PATH.');
    return false;
  }
}

// Optimize video
async function optimizeVideo(inputPath, outputPath, settings, fadeOutStart = null, sourceFps = null) {
  const { width, height, bitrate, crf, fps, format, codec, preset, profile, level } = settings;

  // Use source framerate if available, otherwise fall back to settings fps
  const outputFps = sourceFps !== null ? Math.round(sourceFps) : fps;

  let command = `ffmpeg -i "${inputPath}"`;

  if (codec === 'libx264') {
    command += ` -c:v ${codec} -preset ${preset} -crf ${crf} -maxrate ${bitrate} -bufsize ${parseBitrate(bitrate) * 2} -profile:v ${profile} -level ${level} -pix_fmt yuv420p`;
  } else if (codec === 'libvpx-vp9') {
    command += ` -c:v ${codec} -crf ${crf} -b:v ${bitrate} -maxrate ${bitrate} -minrate ${parseBitrate(bitrate) * 0.5} -pix_fmt yuv420p`;
  }

  // Calculate fade out timing using output framerate
  const fadeOut = fadeOutStart !== null ? fadeOutStart : outputFps * 20 - FADE_DURATION;
  command += ` -vf "scale=${width}:${height}:force_original_aspect_ratio=decrease,pad=${width}:${height}:(ow-iw)/2:(oh-ih)/2,fade=t=in:st=0:d=${FADE_DURATION},fade=t=out:st=${fadeOut}:d=${FADE_DURATION}"`;
  command += ` -r ${outputFps} -g ${outputFps * 2}`;
  command += ` -an -movflags +faststart -f ${format} -y "${outputPath}"`;

  console.log(
    `ðŸŽ¬ Optimizing: ${basename(outputPath)} (${width}x${height}, ${bitrate}, ${outputFps}fps, ${codec})`
  );
  await execAsync(command);

  const { stat } = await import('fs/promises');
  const stats = await stat(outputPath);
  const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
  console.log(`âœ… Complete: ${basename(outputPath)} (${sizeMB} MB)`);
}

// Create poster
async function createPoster(inputPath, outputPath) {
  const command = `ffmpeg -i "${inputPath}" -ss 00:00:00 -vframes 1 -vf "scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2" -y "${outputPath}"`;
  console.log(`\nðŸ–¼ï¸ Creating poster image...`);
  await execAsync(command);
  console.log(`âœ… Poster: ${outputPath}`);
}

async function generateAdaptiveLazyJS(baseName) {
  const utilsDir = join(__dirname, '..', 'js', 'utils');
  const targetPath = join(utilsDir, `${baseName}-lazyload.js`);

  if (existsSync(targetPath)) {
    console.log(`\nâ„¹ï¸ Adaptive lazy-load helper already exists: ${targetPath}`);
    console.log('   Update js/main.js imports manually if you generated a new video name.');
    return;
  }

  const template = `/**
 * Adaptive background video lazy loader
 * Auto-generated by scripts/optimize-video.js
 *
 * This helper selects the optimal background video based on viewport width,
 * connection speed, and browser codec support. It lazy loads the video when
 * the container scrolls into view to reduce initial page weight.
 */
export function initBackgroundVideoLazyLoad() {
  const container = document.getElementById('background-video-container');
  if (!container) return;

  const resolvedBaseName = container.dataset.video || '${baseName}';
  const posterName = container.dataset.poster || \`\${resolvedBaseName}-poster.jpg\`;
  const basePath = container.dataset.path || 'assets/video/optimized';

  const resolveSrc = () => {
    const width = window.innerWidth;
    const isSlowConnection = (() => {
      const connection =
        navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      if (!connection || !connection.effectiveType) return false;
      return (
        connection.effectiveType.includes('2g') || connection.effectiveType.includes('slow-2g')
      );
    })();

    if (isSlowConnection) return \`\${basePath}/\${resolvedBaseName}-lq.mp4\`;

    const supportsWebM = (() => {
      const v = document.createElement('video');
      return typeof v.canPlayType === 'function' && v.canPlayType('video/webm; codecs=vp9') !== '';
    })();

    if (supportsWebM && width >= 769) return \`\${basePath}/\${resolvedBaseName}-webm.webm\`;
    if (width >= 1200) return \`\${basePath}/\${resolvedBaseName}-hq.mp4\`;
    if (width >= 768) return \`\${basePath}/\${resolvedBaseName}-mq.mp4\`;
    return \`\${basePath}/\${resolvedBaseName}-lq.mp4\`;
  };

  const createVideo = src => {
    const video = document.createElement('video');
    video.dataset.src = src;
    video.src = src;
    video.autoplay = true;
    video.muted = true;
    video.loop = true;
    video.playsInline = true;
    video.poster = \`\${basePath}/\${posterName}\`;
    video.className = 'background-video';
    video.setAttribute('aria-hidden', 'true');
    video.setAttribute('tabindex', '-1');
    return video;
  };

  const loadVideo = () => {
    const source = resolveSrc();
    if (!source) return;

    const existing = container.querySelector('video');
    if (existing && existing.dataset.src === source) return;

    if (existing) {
      existing.pause();
      existing.remove();
    }

    const videoEl = createVideo(source);
    container.appendChild(videoEl);

    const onReady = () => {
      videoEl.classList.add('is-ready');
      videoEl.play().catch(() => {});
    };

    if (videoEl.readyState >= 2) onReady();
    else videoEl.addEventListener('loadeddata', onReady, { once: true });
  };

  const observer = new IntersectionObserver(
    entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          loadVideo();
          observer.disconnect();
        }
      });
    },
    { rootMargin: '0px 0px 200px 0px' }
  );

  observer.observe(container);
}
`;

  try {
    await writeFile(targetPath, template, 'utf8');
    console.log(`\nðŸ§© Generated adaptive lazy-load helper: ${targetPath}`);
    console.log('   Import this module in js/main.js to initialize the background video.');
  } catch (error) {
    console.error('âš ï¸ Failed to generate adaptive lazy-load helper:', error);
  }
}

// Get video duration for fade calculation
async function getVideoDuration(inputPath) {
  try {
    const { stdout } = await execAsync(
      `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${inputPath}"`
    );
    const duration = parseFloat(stdout.trim());
    return isNaN(duration) ? 20 : duration; // Fallback to 20 seconds if parsing fails
  } catch {
    // Fallback to default if ffprobe fails or not available
    return 20; // Default 20 seconds
  }
}

// Get source video framerate
async function getVideoFramerate(inputPath) {
  try {
    const { stdout } = await execAsync(
      `ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 "${inputPath}"`
    );
    const frameRateStr = stdout.trim();
    if (!frameRateStr || frameRateStr === 'N/A') {
      // Try alternative method
      const { stdout: altStdout } = await execAsync(
        `ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 "${inputPath}"`
      );
      const altFrameRateStr = altStdout.trim();
      if (!altFrameRateStr || altFrameRateStr === 'N/A') {
        return null;
      }
      const [num, den] = altFrameRateStr.split('/').map(Number);
      return den && den > 0 ? num / den : null;
    }
    const [num, den] = frameRateStr.split('/').map(Number);
    return den && den > 0 ? num / den : null;
  } catch {
    return null;
  }
}

// Process a single video file
async function processVideo(videoFile) {
  const inputPath = join(__dirname, '..', INPUT_DIR, videoFile);
  const baseName = basename(videoFile, extname(videoFile));

  console.log(`\nðŸ“¹ Processing: ${videoFile}`);
  console.log('â”€'.repeat(50));

  // Get video duration for fade calculation
  const duration = await getVideoDuration(inputPath);
  const fadeOutStart = Math.max(duration - FADE_DURATION, FADE_DURATION);

  // Get source video framerate
  const sourceFps = await getVideoFramerate(inputPath);
  if (sourceFps !== null) {
    console.log(`ðŸ“Š Source framerate: ${sourceFps.toFixed(2)} fps`);
  } else {
    console.log(`âš ï¸  Could not detect source framerate, using settings defaults`);
  }

  // Process all quality variants
  for (const key of Object.keys(SETTINGS)) {
    const outputPath = join(
      __dirname,
      '..',
      OUTPUT_DIR,
      `${baseName}-${key}.${SETTINGS[key].format}`
    );

    // Skip if already exists (comment out to force re-encoding)
    if (existsSync(outputPath)) {
      console.log(`â­ï¸  Skipping ${basename(outputPath)} (already exists)`);
      continue;
    }

    // Update fade out timing based on actual video duration
    const settings = { ...SETTINGS[key] };
    await optimizeVideo(inputPath, outputPath, settings, fadeOutStart, sourceFps);
  }

  // Create poster images
  const posterJpg = join(__dirname, '..', OUTPUT_DIR, `${baseName}-poster.jpg`);
  if (!existsSync(posterJpg)) {
    await createPoster(inputPath, posterJpg);
  } else {
    console.log(`â­ï¸  Skipping poster (already exists)`);
  }

  // Generate adaptive lazy-load helper (only once, skip if exists)
  await generateAdaptiveLazyJS(baseName);
}

// Main
async function main() {
  console.log('ðŸŽ¥ Video Optimization Script');
  console.log('============================\n');

  if (!(await checkFFmpeg())) process.exit(1);

  const inputDir = join(__dirname, '..', INPUT_DIR);
  if (!existsSync(inputDir)) {
    console.error(`âŒ Input directory not found: ${inputDir}`);
    process.exit(1);
  }

  if (!existsSync(join(__dirname, '..', OUTPUT_DIR))) {
    mkdirSync(join(__dirname, '..', OUTPUT_DIR), { recursive: true });
  }

  // Read all files from input directory
  const files = await readdirAsync(inputDir);

  // Filter for video files (exclude optimized directory and non-video files)
  const videoFiles = files.filter(file => {
    const ext = extname(file).toLowerCase();
    return VIDEO_EXTENSIONS.includes(ext);
  });

  if (videoFiles.length === 0) {
    console.log('â„¹ï¸  No video files found in assets/video directory.');
    console.log(`   Supported formats: ${VIDEO_EXTENSIONS.join(', ')}`);
    process.exit(0);
  }

  console.log(`Found ${videoFiles.length} video file(s) to process:\n`);
  videoFiles.forEach((file, index) => {
    console.log(`  ${index + 1}. ${file}`);
  });

  // Process each video file
  for (let i = 0; i < videoFiles.length; i++) {
    await processVideo(videoFiles[i]);
    if (i < videoFiles.length - 1) {
      console.log('\n'); // Add spacing between videos
    }
  }

  console.log('\nðŸŽ‰ All done! Optimized videos and posters ready for infinite background playback.');
  console.log(`\nðŸ“ Output directory: ${join(__dirname, '..', OUTPUT_DIR)}`);
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
